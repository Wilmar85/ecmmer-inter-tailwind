<?php

namespace App\Http\Controllers;

use App\Models\SupportTicket;
use App\Models\TicketResponse;
use App\Models\TicketAttachment;
use App\Models\User;
use App\Mail\TicketCreated;
use App\Mail\TicketResponse as TicketResponseMail;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use Illuminate\Validation\Rule;

class SupportTicketController extends Controller
{
    /**
     * Create a new controller instance.
     */
    public function __construct()
    {
        $this->middleware('auth');
    }

    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        $tickets = Auth::user()->tickets()
            ->with('latestResponse')
            ->latest()
            ->paginate(10);

        return view('support.tickets.index', compact('tickets'));
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        return view('support.tickets.create');
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'subject' => 'required|string|max:255',
            'description' => 'required|string|min:10',
            'priority' => 'required|in:low,medium,high,urgent',
            'attachments.*' => 'nullable|file|max:10240|mimes:jpg,jpeg,png,pdf,doc,docx,txt',
        ]);

        // Crear el ticket
        $ticket = Auth::user()->tickets()->create([
            'email' => Auth::user()->email,
            'subject' => $validated['subject'],
            'description' => $validated['description'],
            'priority' => $validated['priority'],
            'status' => 'open'
        ]);

        // Manejar archivos adjuntos si existen
        if ($request->hasFile('attachments')) {
            $this->handleAttachments($request, $ticket->responses()->create([
                'user_id' => Auth::id(),
                'content' => $validated['description'],
                'is_customer_response' => true
            ]));
        }

        // Enviar notificación por correo
        Mail::to($ticket->email)->queue(new TicketCreated($ticket));

        return redirect()
            ->route('support.tickets.show', $ticket)
            ->with('success', __('support.messages.ticket_created', [
                'reference' => $ticket->reference_number
            ]));
    }

    /**
     * Display the specified resource.
     */
    public function show(SupportTicket $ticket)
    {
        $this->authorize('view', $ticket);
        
        // Marcar como leído si es el usuario asignado o el propietario
        if (Auth::user()->isSupportAgent() || $ticket->user_id === Auth::id()) {
            $ticket->markAsRead();
        }
        
        $ticket->load(['responses.user', 'responses.attachments']);
        
        return view('support.tickets.show', compact('ticket'));
    }

    /**
     * Store a new response for the ticket.
     */
    public function storeResponse(Request $request, SupportTicket $ticket)
    {
        $this->authorize('respond', $ticket);

        $validated = $request->validate([
            'content' => 'required|string|min:10',
            'attachments.*' => 'nullable|file|max:10240|mimes:jpg,jpeg,png,pdf,doc,docx,txt',
        ]);

        // Crear la respuesta
        $response = $ticket->responses()->create([
            'user_id' => Auth::id(),
            'content' => $validated['content'],
            'is_customer_response' => Auth::user()->isCustomer()
        ]);

        // Manejar archivos adjuntos si existen
        if ($request->hasFile('attachments')) {
            $this->handleAttachments($request, $response);
        }

        // Actualizar el estado del ticket
        $status = Auth::user()->isCustomer() ? 'in_progress' : 'awaiting_response';
        $ticket->update(['status' => $status]);

        // Enviar notificación por correo
        if (Auth::user()->isCustomer()) {
            // Notificar al personal de soporte
            $supportUsers = User::whereIn('role', ['admin', 'support_agent'])->get();
            
            foreach ($supportUsers as $user) {
                Mail::to($user->email)->queue(new TicketResponseMail($ticket, $response, $user));
            }
        } else {
            // Notificar al cliente
            Mail::to($ticket->email)->queue(new TicketResponseMail($ticket, $response, $ticket->user));
        }

        return redirect()
            ->route('support.tickets.show', $ticket)
            ->with('success', __('support.messages.response_sent'));
    }

    /**
     * Update the status of the specified ticket.
     */
    public function updateStatus(Request $request, SupportTicket $ticket)
    {
        $this->authorize('update', $ticket);

        $validated = $request->validate([
            'status' => ['required', 'string', Rule::in([
                'open', 'in_progress', 'awaiting_response', 'resolved', 'closed'
            ])],
            'comment' => 'nullable|string|max:500'
        ]);

        $previousStatus = $ticket->status;
        $ticket->update(['status' => $validated['status']]);

        // Si se agregó un comentario junto con el cambio de estado
        if (!empty($validated['comment'])) {
            $response = $ticket->responses()->create([
                'user_id' => Auth::id(),
                'content' => '**Cambio de estado:** ' . __('support.status.' . $previousStatus) . ' → ' . 
                             __('support.status.' . $validated['status']) . "\n\n" . 
                             $validated['comment'],
                'is_customer_response' => false
            ]);

            // Notificar al usuario sobre el cambio de estado
            if ($ticket->user_id !== Auth::id()) {
                Mail::to($ticket->email)->queue(new TicketResponseMail($ticket, $response, $ticket->user));
            }
        }

        return redirect()
            ->route('support.tickets.show', $ticket)
            ->with('success', __('support.messages.status_updated'));
    }

    /**
     * Handle file uploads for ticket responses.
     */
    /**
     * Handle file uploads for ticket responses.
     */
    protected function handleAttachments(Request $request, $response)
    {
        if (!$request->hasFile('attachments')) {
            return;
        }

        foreach ($request->file('attachments') as $file) {
            $path = $file->store('ticket_attachments/' . date('Y/m/d'), 'public');
            
            $response->attachments()->create([
                'original_name' => $file->getClientOriginalName(),
                'path' => $path,
                'mime_type' => $file->getClientMimeType(),
                'size' => $file->getSize(),
            ]);
        }
    }

    /**
     * Upload an attachment to a ticket.
     */
    public function uploadAttachment(Request $request, SupportTicket $ticket)
    {
        $this->authorize('update', $ticket);

        $validated = $request->validate([
            'file' => 'required|file|max:10240|mimes:jpg,jpeg,png,pdf,doc,docx,txt',
            'response_id' => 'required|exists:ticket_responses,id,ticket_id,' . $ticket->id,
        ]);

        $response = $ticket->responses()->findOrFail($validated['response_id']);
        $file = $request->file('file');
        
        $path = $file->store('ticket_attachments/' . date('Y/m/d'), 'public');
        
        $attachment = $response->attachments()->create([
            'original_name' => $file->getClientOriginalName(),
            'path' => $path,
            'mime_type' => $file->getClientMimeType(),
            'size' => $file->getSize(),
        ]);

        return response()->json([
            'success' => true,
            'attachment' => [
                'id' => $attachment->id,
                'original_name' => $attachment->original_name,
                'url' => $attachment->url,
                'size' => $this->formatBytes($attachment->size),
                'icon' => $attachment->file_icon,
            ]
        ]);
    }

    /**
     * Download an attachment.
     */
    public function downloadAttachment(TicketAttachment $attachment)
    {
        $this->authorize('view', $attachment->ticketResponse->ticket);

        if (!Storage::disk('public')->exists($attachment->path)) {
            abort(404);
        }

        $headers = [
            'Content-Type' => $attachment->mime_type,
            'Content-Disposition' => 'attachment; filename="' . $attachment->original_name . '"',
        ];

        return Storage::disk('public')->download($attachment->path, $attachment->original_name, $headers);
    }

    /**
     * Format bytes to a human-readable format.
     */
    protected function formatBytes($bytes, $precision = 2)
    {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= (1 << (10 * $pow));
        
        return round($bytes, $precision) . ' ' . $units[$pow];
    }
}
